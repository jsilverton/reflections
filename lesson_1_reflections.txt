Reflections 1
Why good to have diff to find bugs:
- can see changes between when it worked and when it didn't.

How could having easy access to the entire history of a file make you a more efficient programmer in the long term?
Can see who make changes if you have questions
Can add a deleted change back in, or revert a change
Can see when a change was made

Reflections 2 - Manual commit
What do you think are the pros and cons of manually choosing when to create a commit, like you do in Git, vs having versions automatically saved, like Google docs does?
Con - you may forget to commit and lose work if powercut/other accident
Pro - you can choose to commit at opportune moments, at points which make sense to you, in terms of rolling back

Reflect: Multi-File Commits
Why do you think some version control systems, like Git, allow saving multiple files in one commit, while others, like Google Docs, treat each file separately?
- Git is more likely to be used as a code repository, where file dependencies are more common

Reflect: Using Git to View History
How can you use the commands git log and git diff to view the history of files?
git log shows all the changes that have been made
git diff log1id log2id shows the differences that 1 specific commit made

Reflect: Confidence from Version Control
How might using version control make you more confident to make changes that could break something?
- can identify what caused the breakage
- can revert back to previously working version

Reflect: How Do You Want to Use Git?
Now that you have your workspace set up, what do you want to try using Git for?
- want to get more expert at using git to checkout, checkin and commit changes to git and analyse changes outstanding

GIT Commands
--------
git log 												--see all commits (history)
git diff log1id log2id (note - can enter 1st 4+ chars of commmit id) -- compare 2 commits (get id from log)
git checkout [log1id]									--get specific version down to machine
q 														--quit log
[down arrow] 											--navigate through log entries

git init												--create new git repository in the dir you're in (adds .git file)
git status												--file changes
git add [filename]										--add new file to staging area, before gets put into repository and version tracked



- copy & paste - Properties, Options, set quick edit mode (copy text by selecting it and then right clicking, and you can paste by right clicking without anything selected.


subl = launch sublime editor (see setup below so this works)

configuring git
---------------
Downloading necessary files

Save this file in your home directory with the name git-completion.bash.
Save this file in your home directory with the name git-prompt.sh.
Save bash_profile_course from the Downloadables section in your home directory with the name .bash_profile. (If you're curious to learn more about how bash prompts work, see this page.)
Making Git configurations

Run the following Git configuration commands. The first one will need to be modified if you are using a text editor other than Sublime, or if Sublime is installed in another location for you. See this page for the correct command for a couple of other popular text editors. For any other editor, you'll need to enter the command you use to launch that editor from Git Bash.

git config --global core.editor "'C:/Program Files/Sublime Text2/sublime_text.exe' -n -w"
git config --global push.default upstream
git config --global merge.conflictstyle diff3
Make sure you can start your editor from Git Bash

If you use Sublime, you can do this by adding the following line to your .bash_profile:

alias subl="C:/Program\ Files/Sublime\ Text\ 2/sublime_text.exe"
Restart Git Bash

You'll need to close and re-open Git Bash before all your changes take effect.
